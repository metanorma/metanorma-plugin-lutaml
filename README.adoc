= Metanorma LutaML plugin (metanorma-plugin-lutaml)

image:https://github.com/metanorma/metanorma-plugin-lutaml/workflows/rake/badge.svg["Build Status", link="https://github.com/metanorma/metanorma-plugin-lutaml/actions?workflow=rake"]

== Purpose

LutaML is a data model accessor that supports various data model formats.

This plugin allows you to access the following types of information models from
within a Metanorma document:

* EXPRESS (`*.exp` files)
* LutaML-UML (`*.lutaml` files)
* Enterprise Architect exported UML in XMI format (`*.xmi` files)
* LutaML GML Dictionary (`*.xml` files)
* JSON or YAML files (`*.json|*.yml|*.yaml` files)

== Installation

[source,console]
----
$ gem install metanorma-plugin-lutaml
----


== Usage with EXPRESS

=== General

The LutaML plugin supports working with EXPRESS schema files to render EXPRESS
models and definitions.

LutaML supports accessing EXPRESS models via the
https://github.com/lutaml/expressir[Expressir] parser.


=== Document attribute `:lutaml-express-index:`

This attribute allows specifying one or more EXPRESS files to defined names
for later use with `lutaml_express` command.

Syntax:

[source,adoc]
----
:lutaml-express-index: shortname_of_index; name_of_schemas_listing_file.yml;
----

Where:

`shortname_of_index`:: is name of the parsed EXPRESS files context for the later
use.

`name_of_schemas_listing_file.yml`:: location of the YAML index file to parse
all EXPRESS files listed within.


[example]
.Define an index in the document and use it in the `lutaml_express` command
====
[source,adoc]
-----
:lutaml-express-index: my_custom_name; /path/to/schemas.yml

[lutaml_express,my_custom_name,context]
----
{% for schema in context.schemas %}
== {{schema.id}}

{% for entity in schema.entities %}
=== {{entity.id}}
{% endfor %}

{% endfor %}
-----

Where the `schemas.yml` file contains:

[source,yaml]
----
---
schemas:
  action_schema:
    path: "../../schemas/resources/action_schema/action_schema.exp"
  application_context_schema:
    path: "../../schemas/resources/application_context_schema/application_context_schema.exp"
----
====


=== Schemas listing file

The schemas listing file is a YAML file that lists all EXPRESS files to be
parsed. The file should have the following structure:

[source,yaml]
----
---
schemas:
  schema_name:
    path: path/to/schema_file.exp
  schema_name_2:
    path: path/to/schema_file_2.exp
----

Where:

`schema_name`:: is the name of the EXPRESS schema.

`path`:: (optional) path to the EXPRESS schema file. When the path is not
specified, the command will look for the schema file in the directory where the
YAML file is located using the filename pattern `{schema_name}.exp`. The path
can be relative to the YAML file or an absolute path.


=== Usage of the `lutaml_express` command

Given an `example.exp` EXPRESS file with content:

[source,exp]
----
SCHEMA test_schema 'test';

(* Need select elements for measure_value *)
 REFERENCE FROM measure_schema
   (measure_value);

  TYPE my_type1 = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE my_type2 = EXTENSIBLE ENUMERATION;
  END_TYPE;

  TYPE my_type3 = EXTENSIBLE ENUMERATION;
  END_TYPE;

  TYPE my_type4 = EXTENSIBLE ENUMERATION;
  END_TYPE;

  TYPE my_type5 = EXTENSIBLE ENUMERATION;
  END_TYPE;
END_SCHEMA;
----

And the `lutaml_express` block:

[source,adoc]
-----
[lutaml_express_liquid,example.exp,my_context]
----
{% for schema in my_context.schemas %}
== {{schema.id}}

{% for entity in schema.entities %}
=== {{entity.id}}
{% endfor %}

{% endfor %}
----
-----

NOTE: The `lutaml` command can auto-detect the EXPRESS schema file type by the
file extension. If the file extension is `.exp`, the command will use the
`Expressir` parser to parse the file. If the file extension is `.lutaml`, the
command will use the `Lutaml` parser to parse the file.

Where:

* content within the block is called the "`template`";

* `{example.exp}` is the location of the EXPRESS schema file (`*.exp`) that
contains data to be loaded. Location of the file is computed relative to the
source directory that `[lutaml_express_liquid]` is used (e.g., if
`[lutaml_express_liquid,example.exp,my_context]` is invoked in an `.adoc` file
located at `/foo/bar/doc.adoc`, the data file is expected to be found at
`/foo/bar/example.exp`);

* `{my_context}` is the name where the EXPRESS Repository read from the `.exp`
file can be accessed with.

** The `context` object is a serialized `Expressir::Model::Repository` object
with all variable names available. See
https://github.com/lutaml/expressir[Expressir] docs for reference.
`{my_context}` has `schemas` method to access Expressir
https://github.com/lutaml/expressir/blob/master/lib/expressir/model/schema.rb[schemas]

Will produce this output:

____
== test_schema

=== my_type1
=== my_type2
=== my_type3
=== my_type4
=== my_type5
____


Instead of using the direct path to the file one can use `:lutaml-express-index:`
document attribute to supply directory with express files or YAML index file to
parse as well as the cache file location.

Syntax:

[source,adoc]
----
:lutaml-express-index: my_custom_name; dir_or_index_path[; cache=cache_path]
----

Where:

`my_custom_name`:: is name of the parsed EXPRESS files context for the later
use with lutaml command

`dir_or_index_path`:: location of directory with EXPRESS files or path to the
YAML index file to parse

`cache_path`:: (optional) location of the Expressir cache file to use

Example of usage:

[source,adoc]
-----
= Document title
Author
:lutaml-express-index: index_name; /path/to/express_files; cache=/path/to/cache_file.yaml

[lutaml_express_liquid,index_name,context]
----
{% for schema in context.schemas %}
== {{schema.id}}
{% endfor %}
----
-----

* The `lutaml_express_liquid` macro processes the EXPRESS files specified by
  the `index_name` and makes them available in the `context` as
  Liquid Drops object.

* The Liquid template inside the macro block iterates over the `schemas` in
  the `context` and renders the attributes of each schema such as `id`.

=== Using `config_yaml`

This functionality allows `[lutaml_express_liquid]` blocks to load a full set of
EXPRESS schemas in one index, and then provide a select ("filter") option
per-block via a separate YAML file.

[source,adoc]
-----
:lutaml-express-index: all_schemas; ../schemas_all.yaml;

[lutaml_express_liquid,all_schemas,context,config_yaml=schemas.yaml]
---
{% assign all_schemas = repo.schemas  %}
{% render "templates/resources/schema" for ordered_schemas as schema %}
----
-----

Where `schemas_all.yml` provides all schemas:

[source,yaml]
----
---
schemas:
  action_schema:
    path: "../../schemas/resources/action_schema/action_schema.exp"
  application_context_schema:
    path: "../../schemas/resources/application_context_schema/application_context_schema.exp"
  approval_schema:
    path: "../../schemas/resources/approval_schema/approval_schema.exp"
...
----

And `schemas.yaml` only selects 2 schemas:

[source,yaml]
----
---
schemas:
  action_schema:
    anything: ...
  application_context_schema:
    anything: ...
----

The resulting block adds the `ordered_schemas` context to allows you to filter
out the schemas you want to render according to the order in the config_yaml.

[source,liquid]
----
[lutaml_express_liquid,schemas_1,repo,config_yaml=select.yaml]
---
{% assign all_schemas = repo.schemas  %}
{% render "templates/resources/schema" for ordered_schemas as schema %}
...
---
----

NOTE: This functionality is used in the ISO 10303 SRL to load the full schema
set at once but only render the selected schemas in individual documents.

=== Using `include_path`

This functionality allows `[lutaml_express_liquid]` blocks to load templates
from the paths other than the location of the document.

[source,adoc]
-----
:lutaml-express-index: all_schemas; ../schemas_all.yaml;

[lutaml_express_liquid,all_schemas,context,config_yaml=schemas.yaml,include_path=../templates]
---
{% assign all_schemas = repo.schemas  %}
{% render "templates/resources/schema" for ordered_schemas as schema %}
...
----
-----

The resulting block adds the `include_path` to the Liquid renderer.  The path is
resolved based on the location of the document.  You can add multiple paths by
separating them with commas.

== Usage with Lutaml-UML

=== General

The LutaML plugin supports working with LutaML UML files to render UML diagrams
and class definitions.


=== Rendering a LutaML view: `lutaml_diagram`

This command allows to quickly render a LutaML view as an image file.

Given a file `example.lutaml` file with content:

[source,java]
----
diagram MyView {
  title "my diagram"

  enum AddressClassProfile {
    imlicistAttributeProfile: CharacterString [0..1] {
      definition
        this is multiline with `asciidoc`
      end definition
    }
  }

  class AttributeProfile {
    +addressClassProfile: CharacterString [0..1]
    imlicistAttributeProfile: CharacterString [0..1] {
      definition this is attribute definition
    }
  }
}
----

The `lutaml_diagram` command will add the image to the document.

[source,adoc]
----
lutaml_diagram::example.lutaml[]
----

The `lutaml_diagram` command can also be used to denote a block with an embedded
LutaML view.

For example:

[source,java]
----
[lutaml_diagram]
....
diagram MyView {
  title "my diagram"

  enum AddressClassProfile {
    imlicistAttributeProfile: CharacterString [0..1] {
      definition {
        This is multiline AsciiDoc content.
      }
    }
  }

  class AttributeProfile {
    +addressClassProfile: CharacterString [0..1]
    imlicistAttributeProfile: CharacterString [0..1] {
      definition this is attribute definition
    }
  }
}
....
----

== Usage with Enterprise Architect (UML in XMI)

=== General

The LutaML plugin supports working with Enterprise Architect exported XMI files
to render UML diagrams and class definitions.

The commands are prefixed as `lutaml_ea_*` to denote their specific use with
Enterprise Architect XMI files.


=== Document attribute `:lutaml-xmi-index:`

This attribute allows specifying one or more XMI files to defined names
for later use with `lutaml_ea_*` commands.

Syntax:

[source,adoc]
----
:lutaml-xmi-index: index_name; index_path[; config=config_path]
----

where:

`index_name`:: name of index
`index_path`:: path to XMI file for the later use with `lutaml_ea_*` command
`config_path`:: optional, location of YAML configuration file that specifies
what packages to include in the render, what render style is desired and
location of the root package.


[example]
.Define two indexes in the document and use them in the `lutaml_ea_xmi` command
====
[source,adoc]
----
:lutaml-xmi-index: first-xmi-index; /path/to/first.xmi
:lutaml-xmi-index: second-xmi-index; /path/to/second.xmi; config=/path/to/config.yml

[lutaml_ea_xmi,index=first-xmi-index]
--
...
--

lutaml_ea_diagram::[name="NameOfDiagramInSecondXmiIndex",base_path="./xmi-images",format="png",index="second-xmi-index"]
...
----

The command `lutaml_ea_xmi` will load the XMI file from the path
`/path/to/first.xmi` which is specified by the `index`: `first-xmi-index`.

The command `lutaml_ea_diagram` will load the XMI file from the path
`/path/to/second.xmi` which is specified by the `index`: `second-xmi-index`.
====


=== Rendering a Enterprise Architect diagram from XMI: `lutaml_ea_diagram`

This command allows to quickly render a LutaML diagram as an image file by
specifying the name of diagram.

Syntax:

[source,adoc]
----
lutaml_ea_diagram::[{options}]
----

where `{options}` is a hash of options, where:

`name`:: (mandatory) name of the diagram to render.
`base_path`:: (mandatory) base path where the diagram images are located.
`format`:: (optional) format of the image file. Defaults to `png`.
`index`:: (optional) index name of the XMI file. If the index is not provided,
the command will look for the diagram in the first XMI file specified through
the `lutaml_ea_xmi` command.
`package`:: (optional) name of the package which contains the diagram. If the
package is not provided, the command will look for the diagram across all
packages in the XMI file.

The diagram with name `name_of_diagram` will be converted into the following
Metanorma block:

[source,adoc]
----
[[figure-{{ diagram.xmi_id }}]]
.{{ diagram.name }}
image::{{ image_base_path }}/{{ diagram.xmi_id }}.{{ format | default: 'png' }}[]
----

[example]
.Specifying a diagram within an XMI file
====
[source,adoc]
----
lutaml_ea_diagram::[name="name_of_diagram",base_path="/path/to/xmi-images",format="png"]
----

Renders the diagram with name `name_of_diagram` from the XMI file in PNG format,
where the EA images exported with the XMI file are at `/path/to/xmi-images`.
====

[example]
.Specifying a diagram within a specific package (if there are multiple diagrams with the same name)
====
[source,adoc]
----
lutaml_ea_diagram::[name="DiagramName",package="PackageA",base_path="/path/to/xmi-images"]
----

The search wil be restricted to the diagrams named `DiagramName` in the
`PackageA` package.
====

[example]
.Specifying a diagram using a specific index
====
[source,adoc]
----
:lutaml-xmi-index: index_name; /path/to/xmi-file.xmi

...

lutaml_ea_diagram::[name="name_of_diagram",base_path="/path/to/xmi-images",format="png",index="index_name"]
----

Renders the diagram with name `name_of_diagram` from the XMI file in PNG format,
where the EA images exported with the XMI file are at `/path/to/xmi-images` and
the XMI file defined in the index `index_name`.
====



=== Generating a class definition table for a class: `lutaml_klass_table`

This command allows to render a LutaML table of a class by using Liquid Drop.

The table will show:

* Class Name
* Class Definition
* Inherited Properties
* Self-defined Properties
* Properties Inherited from Association
* Properties Defined in Association

[source,adoc]
----
lutaml_klass_table::/path/to/example.xmi[name="NameOfClass",template="/path/to/templates/_my_klass_table.liquid"]
----

The command accepts the options listed below:

* `/path/to/example.xmi` specifies the path of xmi file.

* `name` option only, `name` option with `package` option or `path` option.
  One of 3 forms of options can be used to specify the name of the class.

** `name="NameOfClass"` specifies the name of the `class`.
   (e.g. `name="Building"`)
   If there are multiple classes with the same name, other form of options
   are recommended to specify the class.

** `package="NameOfPackage"name="NameOfClass"` specifies the name of the
   `class` (specified by `name` option) inside the `package`
   (specified by `package` option).
   The `package` option must be used with the `name` option.
   (e.g. `package="uro",name="_BoundarySurface"`)

** `path="PathOfClass"` specifies the `absolute` path of the `class`
   which is started with `::`
   (e.g. `path="::EA_Model::Conceptual Models::i-UR::Urban Planning ADE 3.
   1::uro::_BoundarySurface"`)
   or `relative` path of the `class` which is not started with `::`
   (e.g. `path="uro::_BoundarySurface"`).
   The last part of the path separated by `::` is the name of the `class`.
   The other parts of the path are the names of the `packages`.

* `template="/path/to/templates/_my_klass_table.liquid"` specifies the path of
  the liquid template. (Optional)
  By default, it will look for the template `_klass_table.liquid` defined in
  `lib/metanorma/plugin/lutaml/templates`.  This template can be customized by
  changing the template path in the `template` option.

* `guidance="/path/to/my_guidance.yml"` specifies the path of
  the yaml file of the guidance. (Optional)

The guidance file should be in the following format:

[source,yaml]
----
---
classes:
  - name: Name Of Class
    attributes:
      - name: Name Of Attribute (e.g. gml:boundedBy)
        used: false
        guidance: |
          Drop guidance message here.
...
----

If you want to define the guidance, you can define the `name` of the class
under `classes`.  Then define which `attributes` you want to add guidance by the
`name`. Set `used` to show the attribute is used or not. Drop the message of
guidance in `guidance`.




=== Usage of `lutaml_ea_xmi` command

The `lutaml_ea_xmi` command supersedes the `lutaml_uml_datamodel_description`
command which it is functionally equivalent to.

This command renders data model packages and its dependent objects for supplied
XMI file, by using Liquid Drop objects.

NOTE: The performance of `lutaml_ea_xmi` exceeds
`lutaml_uml_datamodel_description` by 10~20 times (Tested with a 10.6MB XMI file
with 120,000+ lines).

NOTE: To migrate to this command from `lutaml_uml_datamodel_description`, just
replace the command `lutaml_uml_datamodel_description` by `lutaml_ea_xmi`.

Replace:

[source,adoc]
----
[lutaml_uml_datamodel_description, path/to/example.xmi]
...
----

By:

[source,adoc]
----
[lutaml_ea_xmi, path/to/example.xmi]
...
----

You can define guidance in the configuration file as well. The configuration
file will looks like:

[source,yaml]
----
packages:
- my_package
guidance: "path/to/guidance.yaml"
----

The guidance file should be in the following format:

[source,yaml]
----
---
classes:
- name: "NameOfClass"
  attributes:
  - name: Name Of Attribute (e.g. gml:boundedBy)
    used: false
    guidance: |
      Drop guidance message here.
...
----

If you want to define the guidance, you can define the `name` of the class
under `classes`.  Then define which `attributes` you want to add guidance by the
`name`. Set `used` to show the attribute is used or not. Drop the message of
guidance in `guidance`.

The `name` of class can be defined in the following ways:

* `name: "NameOfClass"` specifies the name of the `class`.
  (e.g. `name: "Building"`)
  If there are multiple classes with the same name, it is recommended to
  specify the class by absolute path.

* `name: "::NameOfPackage::NameOfClass"` specifies the name of the `class` in
  `absolute` path.
  (e.g. `name: "::EA_Model::Conceptual Models::CityGML2.0::bldg::Building"`)


=== Usage of `lutaml_uml_datamodel_description` command

This command allows to quickly render data model packages and its dependent
objects for supplied XMI file.

Given an Enterprise Architect `example.xmi` file with 2 packages:

* 'Another'
* 'CityGML'

The `lutaml_uml_datamodel_description` command can be used:

[source,adoc]
----
[lutaml_uml_datamodel_description, path/to/example.xmi]
--
[.before]
....
my text
....

[.diagram_include_block, base_path="requirements/", format="emf"]
....
Diagram text
....

[.include_block, package="Another", base_path="spec/fixtures"]
....
my text
....

[.include_block, base_path="spec/fixtures"]
....
my text
....

[.before, package="Another"]
....
text before Another package
....

[.after, package="Another"]
....
text after Another package
....

[.after, package="CityGML"]
....
text after CityGML package
....

[.after]
....
footer text
....
--
--
----

Where:

* `path/to/example.xmi` - required, path to the XMI file to render

* `[.before]` - block text that adds additional text before the rendered output, can be used only once, additional occurrences of command will overwrite text, not that `literal` block style must be used in there(eg `....`)

* `[.after]` - block text that adds additional text after the rendered output, can be used only once, additional occurrences of command will overwrite text

* `[.after, package="Another"]` - block text to be inserted before(after in case of `.before` name) the package

* `[.package_text, position="after", package="Another"]` - include custom adoc code into package rendered body, `position` is a a required attribute which tells where to insert the code.

* `[.package_text, package="Another"]` - same as above, but include block will be included only for supplied package name

* `[.diagram_include_block]` - block text to automatically include diagram images. Attribute `base_path` is a required attribute to supply path prefix where to look for a diagram image. `format` is an optional attribute that tells what file extension to use when including diagram file.
+
The logic is as follows:
[source,adoc]
----
{% for diagram in package.diagrams %}
[[figure-{{ diagram.xmi_id }}]]
.{{ diagram.name }}
image::{{ image_base_path }}/{{ diagram.xmi_id }}.{{ format | default: 'png' }}[]

{% if diagram.definition %}
{{ diagram.definition | html2adoc }}
{% endif %}
{% endfor %}
----

For instance, the script will take package diagrams supplied in the XMI file and will try to include `image` with the name equal to diagram' xmi_id attribute plus `.png`. Also one can add any text to the command text, it will be added as paragraph before each image include.

* `[.diagram_include_block, package="Another"]` - same as above, but diagram will be included only for supplied package name

* `[.include_block, base_path="spec/fixtures"]` - command to include files (`*.adoc` or `*.liquid`) for each package name. Attribute `base_path` is a required attribute to supply path prefix where to look for file to include. command will look for a file called `base_path` + `/` `_package_name`(downcase, replace : -> '', ' ' -> '_') + `.adoc`[`.liquid`], eg for package 'My Package name' and `base_path` eq to `my/path`, command will look for the following file path: `my/path/_my_package_name.adoc`.

* `[.include_block, package="Another", base_path="spec/fixtures"]` - same as above, but include block will be included only for supplied package name


NOTE: .after, .before, package_text and include_block commandses all can be used with additional option - `liquid`, if this option is supplied then the code inside block will be interpolated in liquid context


=== Referencing objects generated by LutaML


There are two other commands that are used to refer to LutaML generated document elements:

* `lutaml_figure`. Provides a reference anchor to a figure defined in the XMI
  file, using its XMI ID for reference.

* `lutaml_table`. Provides a reference anchor to the definition tables of a
  particular package, class, enumeration or data type object in the XMI.


The syntax is as follows:

[source,adoc]
----
// For lutaml_figure
This is lutaml_figure::[package="Wrapper root package", name="Fig B1 Full model"] figure

// For lutaml_table
This is lutaml_table::[package="Wrapper root package"] package
This is lutaml_table::[package="Wrapper root package", class="my name"] class
This is lutaml_table::[package="Wrapper root package", enum="my name"] enumeration
This is lutaml_table::[package="Wrapper root package", data_type="my name"] data type
----

This code will be transformed into `<<figure-{diagram.xmi_id}>>` and will point to diagram figure. One can only use this command when document rendered `lutaml_uml_datamodel_description` command as it needs diagram lookup table in order to reference package diagram.

Will produce this output:

[source,adoc]
----
my text
== CityGML package
=== CityGML overview

Diagram text

[[figure-EAID_ACBB5EE3_3428_40f5_9C7C_E41923419F29]]
.CityGML Package Diagram
image::requirements/EAID_ACBB5EE3_3428_40f5_9C7C_E41923419F29.png[]

BuildingFurnitureFunctionValue is a code list that enumerates the different purposes of a BuildingFurniture.

[[figure-EAID_938AE961_1C57_4052_B964_997D1894A58D]]
.Use of ISO and OASIS standards in CityGML
image::requirements/EAID_938AE961_1C57_4052_B964_997D1894A58D.png[]

The CityGML package is organized into
2 packages with 1 modules:

. Another package
. CityTML package

my text

Content for CityGML package

==== Defining tables

.<<section-EAPK_9C96A88B_E98B_490b_8A9C_24AEDAC64293>> -- Elements of &#8220;Another::AbstractAtomicTimeseries&#8221; (class)

[[section-EAPK_9C96A88B_E98B_490b_8A9C_24AEDAC64293]]
.Elements of &#8220;Another::AbstractAtomicTimeseries&#8221; (class)
[width="100%",cols="a,a,a,a,a,a,a,a"]
|===
h|Name: 7+| AbstractAtomicTimeseries
h|Definition: 7+|
h|Stereotype: 7+| interface
h|Abstract: 7+|
h|Associations: 7+| (none)
.4+h|Public attributes:
| _Name_
2+| _Definition_
| _Derived_
| _Obligation_
| _Maximum occurrence_
| _Data type_
| adeOfAbstractAtomicTimeseries
2+|
|
| C
| *
| ADEOfAbstractAtomicTimeseries
| observationProperty
2+|
|
| M
| 1
| CharacterString
| uom
2+|
|
| C
| 1
| CharacterString
h|Constraints: 7+| (none)
|===

=== Additional Information

text after CityGML package
----

In addition to the XMI file, this command also supports a YAML configuration file
that specifies:

* What packages to include in the render;

* What render style is desired;

* Location of the root package (which package should the iterative process start
  at);

* Which EA extensions to be loaded.

The format for using the YAML configuration file:

[source,yaml]
----
---
packages:
  # includes these packages
  - "Package *"
  - two*
  - three
  # skips these packages
  - skip: four
render_style: entity_list | data_dictionary | default
section_depth: 2
ea_extension:
  - "CityGML_MDG_Technology.xml"
  - "xmi_definition_for_some_standard.xml"
----

Where:

* `packages` - required, root element with the list of strings or objects

* `Package *` - pattern matching, specifies lookup condition for packages to
render.
+
NOTE: In this example, it is equal to the following regular expression: `/^Package.*$/`

* `skip: four` - object with package name to skip

* `render_style` - what template to use to render packages, can be one of:

** `entity_list`

** `data_dictionary`; or

** `default`

* `section_depth` - what package to use as root package for render.
e.g., a `section_depth` equal to `2` tells the processor to use the first
nested package of the first root packages in XMI file.
+
EXAMPLE: If the XMI file has this package structure, and we have `section_depth`
equal to 2, root package will be `one-1`.
+
[source,json]
----
[
  {
    name: 'One',
    packages: [{ name: 'one-1' }, { name: 'one-2' }]
  },
  {
    name: 'Two',
    packages: [{ name: 'two-1' }, { name: 'two-2' }]
  }
]
----

* `ea_extension` - optional, list of EA extensions to load. Some XMI files may
contain elements that cannot be resolved by default, for example CityGML
elements.  You can use `ea_extension` to load the definition of these elements
in XML format (`CityGML_MDG_Technology.xml`) in order to resolve them.  The
location of the xml files is relative to the config YAML file.

Usage with command:

[source,adoc]
--
[lutaml_uml_datamodel_description, path/to/example.xmi, path/to/config.yml]
----
[.diagram_include_block, base_path="models/Images", format="png"]
...
...
----
--

The processor will read the supplied YAML config file (`path/to/config.yml`),
and iterate through packages according to the order supplied in the file. All
packages that matches `skip` in the YAML config file will be skipped during
render.




== Usage with LutaML GML Dictionary

=== Rendering a LutaML GML Dictionary: `lutaml_gml_dictionary`

This command allows to render a LutaML GML Dictionary by using Liquid Drop.

GmlDictionaryDrop has the following attributes:

* name
* file_name
* dictionary_entry

Each `dictionary_entry` has the following attributes:

* name
* description

[source,adoc]
----
lutaml_gml_dictionary::/path/to/dictionary.xml[template="/path/to/template.liquid",context=dict]
----

The command accepts the options listed below:

* `/path/to/dictionary.xml` specifies the path of xml file of the
GML Dictionary.

* `template="/path/to/template.liquid"` specifies the liquid template.
  For example, you can create a liquid template and link it by `template`.

* `context=dict` define the context in the template.

[source,adoc]
----
[cols="3a,22a"]
|===
| Name | {{ dict.file_name }}

h| Code h| Description
{% for entry in dict.dictionary_entry %}
| {{ entry.name }} | {{ entry.description }}
{% endfor %}
|===

[.source]
<<source_link>>
----

In spite of specifying the path of the template, you can also define an inline
template within a block by
`[lutaml_gml_dictionary,"/path/to/dictionary.xml",context=dict]`.

[source,adoc]
----
[lutaml_gml_dictionary,"/path/to/dictionary.xml",context=dict]
--
{% capture link %}https://www.test.com/{{ dict.file_name }}{% endcapture %}

[cols="3a,22a"]
|===
| File Name | {{ dict.file_name }}
h| URL | {{ link }}
h| Help | Description
{% for entry in dict.dictionary_entry %}
| {{ entry.name }} | {{ entry.description }}
{% endfor %}
|===

[.source]
<<source_link>>
--
----



== Usage with JSON or YAML files

=== General

The plugin provides the following block commands:

`data2text`:: Loads one or more JSON/YAML files and makes them available for
use in a Metanorma template context.

`yaml2text`:: Identical to `data2text`, but only loads YAML files.

`json2text`:: Identical to `data2text`, but only loads JSON files.


=== Liquid syntax

These block commands make specified data available in the context of a template
block that supports Liquid. Liquid is a template language that allows you to
create dynamic content through templating.

Liquid supports many templating features, including:

* variables, variable assignment
* flow control (if/case)
* filters
* loops

NOTE: See the introduction to the
https://shopify.github.io/liquid/basics/introduction/[Liquid language] for
reference.

In the following sections, we will use `data2text` as an example, but the
same applies to `yaml2text` and `json2text`.


[[defining_syntax]]
=== Defining a block

A `data2text` block is created by specifying the block name `[data2text]`
followed by a comma and the file paths of the JSON/YAML file and the assigned
context name.

Syntax:

[source,adoc]
--
[data2text,{self-defined-context-name}={data-file-path}{, ...}] <1>
----
Liquid template content
----
--

Where:

* `[data2text]` is the block name;
* `{self-defined-context-name}` is the name of the context where the data
  will be loaded into;
* `{data-file-path}` is the path to the JSON/YAML file to be loaded;
* `{, ...}` is optional and can be used to load multiple files in the same pattern;
* content within the block is called the "`template`". `Liquid template content`
  is the content of the block where Liquid expressions can be used.

NOTE: The block opening and closing is demarcated by a `[source]` block syntax
(`----` or more `-`) or an open block delimiter (`--`).

`data-file-path` can be a relative or absolute path to the JSON/YAML file. If it is
a relative path, it is computed relative to the source where the block is
invoked.

[example]
====
When `[data2text,data=data.yaml]` is invoked from the `foo/bar/doc.adoc` file,
then the data file `foo/bar/data.yaml` is loaded.
====


=== Template environment

Within the template environment, the data loaded from the JSON/YAML file can be
accessed by using the data context name defined in the block.

In addition to the typical Liquid syntax, the following features are available:

* `load_file` filter: loads a data file (of file types supported by `data2text`)
and makes its content available in the template context.


It is important to note that the Liquid template is rendered into a Metanorma
AsciiDoc block. This means that while AsciiDoc syntax can be used within the
template, the Liquid syntax is evaluated first.

[source]
----
┌──────────────────────┐
│                      │
│   JSON/YAML files    │
│                      │
└──────────┬───────────┘
           │
           │ loaded into
           ▼
┌──────────────────────┐        ┌──────────────────────┐
│                      │        │                      │
│  data2text context   │        │  Metanorma Document  │
│                      │        │  (with AsciiDoc      │
└──────────┬───────────┘        │   attributes)        │
           │                    │                      │
           │ available in       └──────────┬───────────┘
           ▼                               │
┌──────────────────────┐                   │
│                      │                   │
│   Liquid Template    │                   │
│   Evaluation         │                   │
│                      │                   │
└──────────┬───────────┘                   │
           │                               │
           │ renders into                  │
           ▼                               │
┌──────────────────────┐                   │
│                      │                   │
│  Rendered Liquid as  │                   │
│  Metanorma AsciiDoc  │                   │
│                      │                   │
└──────────┬───────────┘                   │
           │                               │
           │ becomes                       │
           ▼                               │
┌──────────────────────┐                   │
│                      │◄──────────────────┘
│  Metanorma AsciiDoc  │  evaluated as
│  Content             │  Metanorma AsciiDoc
│                      │
└──────────────────────┘
----



=== AsciiDoc usage within the template

The Liquid template is rendered into a Metanorma AsciiDoc document.
This means that the following AsciiDoc syntax can be used within the template
as Liquid does not interfere with AsciiDoc syntax:

. `{variable}`: as in AsciiDoc syntax;

In `{variable}`(`{{variable}}`), `variable` is the name of the variable or
AsciiDoc attribute.


=== Liquid syntax within the template

As with normal Liquid, you can use the following syntax to access variables
and attributes:

. Rendered variables: `{{ variable }}`

. Control syntaxes: `{% if/else/for/case %}`

. Filters: `{{ variable | filter_name: arg1, arg2 }}`

. Assignments: `{% assign variable = value %}`

. Comments: `{% comment %} ... {% endcomment %}`

. Raw content: `{% raw %} ... {% endraw %}`

. Multi-line Liquid code:
+
[source]
----
{% liquid
assign variable = value
if condition
  ...
else
  ...
endif
%}
{{ variable }}
----


=== Accessing object values

Object values can be accessed via:

* the `.` (dot) separator
* the `[]` (bracket) operator

Syntax:

[source,adoc]
----
{{object_name.key}} <1>
{{object_name["key"]}} <2>
----
<1> `object_name` is the name of the context where the data is loaded,
`key` is the key name in the object.

<2> The bracket syntax can be used when the key name contains special characters
or spaces or when the key name is a variable.


[example]
====
Given:

`strings.yaml`
[source,yaml]
----
---
foo: bar
dead: beef
----

And the block:

[source,asciidoc]
------
[data2text,data=strings.yaml]
----
I'm heading to the {{data.foo}} for {{data.dead}}.
----
------

The file path is `strings.yaml`, and context name is `data`.
`{{data.foo}}` evaluates to the value of the key `foo` in `data`.

Will render as:

[source,asciidoc]
----
I'm heading to the bar for beef.
----
====


When the key name is interpolated, the bracket syntax can be used.

[example]
====
Given:

`strings.yaml`
[source,yaml]
----
---
foo: bar
dead: beef
----

And the block:

[source,asciidoc]
------
[data2text,data=strings.yaml]
----
{% assign key = "foo" %}
I'm heading to the {{data[key]}} for {{data["dead"]}}.
----
------

The file path is `strings.yaml`, and context name is `data`.
`{{data[key]}}` evaluates to the value of the key `foo` in `data`.
`{{data["dead"]}}` evaluates to the value of the key `dead` in `data`.

Will render as:

[source,asciidoc]
----
I'm heading to the bar for beef.
----
====


=== Accessing arrays

==== Length

The length of an array can be obtained by `{{arrayname.size}}`.

[example]
====
Given:

`strings.yaml`
[source,yaml]
----
---
- lorem
- ipsum
- dolor
----

And the block:
[source,asciidoc]
------
[data2text,data=strings.yaml]
----
The length of the YAML array is {{data.size}}.
----
------

The file path is `strings.yaml`, and context name is `data`.

`{{data.size}}` evaluates to the length of the array using liquid `size`
https://shopify.github.io/liquid/filters/size/[filter].

Will render as:
[source,asciidoc]
----
The length of the YAML array is 3.
----
====

==== Enumeration and context

The following syntax is used to enumerate items within an array:

[source,liquid]
--
{% for item in array_name %} <1>
  ...content... <2>
{% endfor %}
--
<1> `array_name` is the name of the existing context that contains array data,
`item` is the current item within the array.
<2> `...content...` is the content of the block within the for-loop.

Within a Liquid
https://shopify.dev/docs/themes/liquid/reference/objects/for-loops[for-loop],
the following expressions can be used:

* `{{forloop.index0}}`: the zero-based position of the item `item_name` within
the parent array

* `{{forloop.length}}`: the total number of iterations of the loop.

* `{{forloop.first}}`: returns `true` if it's the first iteration of the for loop. Returns `false` if it is not the first iteration.

* `{{forloop.last}}`: returns `true` if it's the last iteration of the for loop.
Returns `false` if it is not the last iteration.

* `{{array_name.size}}`: the length of the array `array_name`

* `{{array_name[i]}}`: provides the value at index `i` (this is zero-based:
starts with `0`) in the array `array_name`; `array_name[-1]` can be used to
refer to the last item, `array_name[-2]` the second last item, and so on.


[example]
====
Given:

strings.yaml
[source,yaml]
----
---
- lorem
- ipsum
- dolor
----

And the block:
[source,asciidoc]
------
[data2text,arr=strings.yaml]
----
{% for item in arr %}
=== {{forloop.index0}} {item}

This section is about {item}.

{endfor}
----
------

Where:

* file path is `strings.yaml`
* current context within the enumerator is called `item`
* `{{forloop.index0}}` gives the zero-based position of item `item` in the parent array `arr`.

Will render as:
[source,text]
----
=== 0 lorem

This section is about lorem.

=== 1 ipsum

This section is about ipsum.

=== 2 dolor

This section is about dolor.
----
====



=== Accessing objects

==== Size

Similar to arrays, the number of key-value pairs within an object can be
obtained by `{{objectname.size}}`.

[example]
====
Given:

object.yaml
[source,yaml]
----
---
name: Lorem ipsum
desc: dolor sit amet
----

And the block:
[source,asciidoc]
------
[data2text,data=object.yaml]
----
=== {{data.name}}

{{data.desc}}
----
------

The file path is `object.yaml`, and context name is `data`.
`{{data.size}}` evaluates to the size of the object.

Will render as:
[source,asciidoc]
----
=== Lorem ipsum

dolor sit amet
----
====

==== Enumeration and context

The following syntax is used to enumerate key-value pairs within an object:

[source,liquid]
--
{% for item in object_name %} <1>
  {{item[0]}}, {{item[1]}} <2>
{% endfor %} <3>
--

<1> `object_name` is the name of the existing context that contains the object
<2> `{{item[0]}}` contains the key of the current enumerated object, `{{item[1]}}` contains the value
<3> `{% endfor %}` indicates where the object enumeration block ends


[example]
====
Given:

object.yaml
[source,yaml]
----
---
name: Lorem ipsum
desc: dolor sit amet
----

And the block:
[source,asciidoc]
------
[data2text,my_item=object.yaml]
----
{% for item in my_item %}
=== {{item[0]}}

{{item[1]}}

{% endfor %}
----
------

Where:

* file path is `object.yaml`
* current key within the enumerator is called `item[0]`
* `{{item[0]}}` gives the key name in the current iteration
* `{{item[1]}}` gives the value in the current iteration

Will render as:
[source,text]
----
=== name

Lorem ipsum

=== desc

dolor sit amet
----
====


Moreover, the `keys` and `values` attributes can also be used in object enumerators.


[example]
====
Given:

object.yaml
[source,yaml]
----
---
name: Lorem ipsum
desc: dolor sit amet
----

And the block:
[source,asciidoc]
------
[data2text,item=object.yaml]
----
.{{item.values[1]}}
[%noheader,cols="h,1"]
|===
{% for elem in item %}
| {{elem[0]}} | {{elem[1]}}

{% endfor %}
|===
----
------

Where:

* file path is `object.yaml`
* current key within the enumerator is called `key`
* `{{item[1]}}` gives the value of key in the current iteration the parent array `my_item`.
* `{{item.values[1]}}` gives the value located at the second key within `item`

Will render as:
[source,text]
----
.dolor sit amet

[%noheader,cols="h,1"]
|===
| name | Lorem ipsum
| desc | dolor sit amet
|===
----
====

There are several optional arguments to the `for` tag that can influence which
items you receive in your loop and what order they appear in:

* limit:<INTEGER> lets you restrict how many items you get.
* offset:<INTEGER> lets you start the collection with the nth item.
* reversed iterates over the collection from last to first.

[example]
====
Given:

strings.yaml
[source,yaml]
----
---
- lorem
- ipsum
- dolor
- sit
- amet
----

And the block:
[source,asciidoc]
------
[data2text,items=strings.yaml]
----
{% for elem in items limit:2 offset:2 %}
{{item}}
{% endfor %}
----
------

Where:

* file path is `strings.yaml`
* `limit` - how many items we should take from the array
* `offset` - zero-based offset of item from which start the loop
* `{{item}}` gives the value of item in the array

Will render as:
[source,text]
----
dolor sit
----
====


=== Advanced usage

==== General

The `data2text` block supports a variety of advanced features, including:

* array of objects
* array of arrays
* nested loading of data file paths
* interpolated file names
* multiple contexts
* multiple contexts with mixed file formats

==== Array of objects

[example]
====
Given:

array_of_objects.yaml
[source,yaml]
----
---
- name: Lorem
  desc: ipsum
  nums: [2]
- name: dolor
  desc: sit
  nums: []
- name: amet
  desc: lorem
  nums: [2, 4, 6]
----

And the block:
[source,asciidoc]
------
[data2text,ar=array_of_objects.yaml]
----
{% for item in ar %}

{{item.name}}:: {{item.desc}}

{% for num in item.nums %}
- {{item.name}}: {{num}}
{% endfor %}

{% endfor %}
----
------

Notice we are now defining multiple contexts:

* using different context names: `ar`, `item`, and `num`

Will render as:
[source,asciidoc]
----
Lorem:: ipsum

- Lorem: 2

dolor:: sit

amet:: lorem

- amet: 2
- amet: 4
- amet: 6
----
====


==== Interpolated file names

`data2text` blocks can be used for pre-processing document elements for AsciiDoc
consumption.

[example]
====
Given:

strings.yaml
[source,yaml]
----
---
prefix: doc-
items:
- lorem
- ipsum
- dolor
----

And the block:

[source,asciidoc]
--------
[data2text,yaml=strings.yaml]
------
First item is {{yaml.items.first}}.
Last item is {{yaml.items.last}}.

{% for s in yaml.items %}
=== {{forloop.index0}} -> {{forloop.index0 | plus: 1}} {{s}} == {{yaml.items[forloop.index0]}}

[source,ruby]
----
\include::{{yaml.prefix}}{{forloop.index0}}.rb[]
----

{% endfor %}
------
--------


Will render as:
[source,asciidoc]
------
First item is lorem.
Last item is dolor.

=== 0 -> 1 lorem == lorem

[source,ruby]
----
\include::doc-0.rb[]
----

=== 1 -> 2 ipsum == ipsum

[source,ruby]
----
\include::doc-1.rb[]
----

=== 2 -> 3 dolor == dolor

[source,ruby]
----
\include::doc-2.rb[]
----
------

This block instructs Metanorma to include the file `doc-0.rb`, `doc-1.rb`, and
`doc-2.rb` in the resulting document.
====


==== Multiple contexts

Multiple contexts can be defined in a single block.

[example]
====
Given:

strings1.yaml
[source,yaml]
----
---
foo: bar
dead: beef
----

strings2.yaml
[source,yaml]
----
---
hello: world
color: red
shape: square
----

And the block:
[source,asciidoc]
------
[data2text,data1=data=strings1.yaml2=strings2.yaml]
----
I'm heading to the {{data1.foo}} for {{data1.dead}}.

This is hello {{data2.hello}}.
The color is {{data2.color}} and the shape is {{data2.shape}}.
----
------

The file path is `strings1.yaml`, and context name is `data1`.
`{{data1.foo}}` evaluates to the value of the key `foo` in `data1`.

The file path is `strings2.yaml`, and context name is `data2`.
`{{data2.hello}}` evaluates to the value of the key `hello` in `data2`.

Will render as:
[source,asciidoc]
----
I'm heading to the bar for beef.

This is hello world.
The color is red and the shape is square.
----
====


==== Multiple contexts with mixed file formats

When the file formats are mixed, use the `data2text` block to load multiple
files of different formats.

NOTE: The file format is determined by the file extension of the file path.

[example]
====
Given:

`strings1.json`
[source,json]
----
{
  "foo": "bar",
  "dead": "beef"
}
----

`strings2.yaml`
[source,yaml]
----
---
hello: world
color: red
shape: square
----

And the block:
[source,asciidoc]
------
[data2text,my_json=strings1.json,my_yaml=strings2.yaml]
----
I'm heading to the {{my_json.foo}} for {{my_json.dead}}.

This is hello {{my_yaml.hello}}.
The color is {{my_yaml.color}} and the shape is {{my_yaml.shape}}.
----
------

The file path is `strings1.json`, and context name is `my_json`.
`{{my_json.foo}}` evaluates to the value of the key `foo` in `my_json`.

The file path is `strings2.yaml`, and context name is `my_yaml`.
`{{my_yaml.hello}}` evaluates to the value of the key `hello` in `my_yaml`.

Will render as:
[source,asciidoc]
----
I'm heading to the bar for beef.

This is hello world.
The color is red and the shape is square.
----
====


==== Nested loading of data file paths

There are cases where the data file paths are not known in advance or are
provided via a variable. In such cases, you can use the Metanorma-specific
`load_file` filter to load the data file paths dynamically.

This is useful when the data file paths are provided as part of the data
structure itself or when you want to load data files based on certain
conditions.

[example]
====
Given:

`strings1.json`
[source,json]
----
{
  "foo": "bar",
  "paths": ["a.yaml", "b.yaml"]
}
----

Where:

* `paths` is an array of filepaths relative to the Metanorma document

`a.yaml`
[source,yaml]
----
---
shape: circle
color: red
----

`b.yaml`
[source,yaml]
----
---
shape: square
color: blue
corners: 4
----

And the block:
[source,asciidoc]
------
[data2text,my_context=strings1.json]
----
I'm heading to the {{my_context.foo}}.

{% for path in my_context.paths %}
{% assign data = path | loadfile: "." %}
This is {{ data.shape }} with color {{ data.color }}.
{% endfor %}
----
------

Where:

* `loadfile:` is a liquid filter that loads the file content based on `path`
  with arugment `.`. The arugment is the path of the parent folder, which is the
  current directory of the Metanorma document.

Will render as:
[source,asciidoc]
----
I'm heading to the bar.

This is circle with color red.
This is square with color blue.
----
====


== Documentation

Please refer to https://www.metanorma.org.



== Copyright and license

Copyright Ribose.

Licensed under the MIT License.
